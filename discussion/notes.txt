По замерам/графикам
1. Запуск клиента на другом ноуте
2. Кол-во клиентов не меньше кол-ва ядер (больше в 2-3 раза) (у меня 8 ядер)
3. Клиентов больше, чем ядер - график зависимости от N не обязательно квадратичный
4. Неизменяющиеся параметры должны минимально влиять на результат (для N: задержка 1 слишком мало, 4 клиента - недостаточная нагрузка для 8 ядер (8 клиентов лучше)) - нужно позапускать и понять значение каждой из метрик, при котором она влияет на результат наименьшим образом
5. Замеры, когда все подключились и никто не отключился (начинать считать только после отключения) - использовать защёлку внутри потока со считыванием
6. Прекращаем замеры, когда 1 из клиентов умер (для каждого клиента на сервере хранить кол-во выполненных запросов)

Завершение работы
7. Сервер: exception при отключении 1 из клиентов
8. Клиент: поймали exception - считаем метрики

UI
9. UI общается с сервером (указать тип сервера / получить статистику)
10. UI: куча кнопок для сбора инфы, нажали на большую кнопку "построить" - строим - сохранили в файлик - автоматом построили графики (МОЖНО ЗАПУСКАТЬ JAVA, а потом PYTHON в 1 скрипте!!).

Неблокирующая архитектура
11. Регистрируем на отправку в том же потоке, где находится селектор (чтобы избежать блокировок): есть список очередей буферов для каждого клиента: если какая-то очередь непустая и клиент не зареган - регаем; внутри отправки делаем wakeup - блокировок не надо - после отправки (writeRes) проверяем очередь - если буферов больше нет, разрегестируем

Про исключения:
12. Сервер САМ закрывает всех осташихся клиентов, если кинулось исключение
13. Исключения в тред пуле пробрасываются с ипользованием Future

